use serde::{Deserialize, Serialize};
use std::fs::read_to_string;
use std::path::PathBuf;

use crate::{Error, Result};

/// A query submitted to a model provider for processing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Query {
    /// The text content of the query.
    pub text: String,
    /// Optional conversation identifier for maintaining context across queries.
    pub conversation_id: Option<String>,
    /// Paths to files that provide additional context for the query.
    pub files_context: Vec<PathBuf>,
}

impl Query {
    /// Creates a new query with the given text.
    pub fn new<T: Into<String>>(text: T) -> Self {
        Self {
            text: text.into(),
            conversation_id: None,
            files_context: Vec::default(),
        }
    }

    /// Adds file paths to provide context for this query.
    #[must_use]
    pub fn with_files(mut self, files: Vec<PathBuf>) -> Self {
        self.files_context = files;
        self
    }
}

/// A response generated by a model provider.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    /// The generated text content.
    pub text: String,
    /// Confidence score for the response (0.0 to 1.0).
    pub confidence: f64,
    /// Token usage statistics for this generation.
    pub tokens_used: TokenUsage,
    /// Name of the provider that generated this response.
    pub provider: String,
    /// Time taken to generate the response in milliseconds.
    pub latency_ms: u64,
}

/// Token usage statistics for a model invocation.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TokenUsage {
    /// Number of input tokens processed.
    pub input: u64,
    /// Number of output tokens generated.
    pub output: u64,
    /// Number of tokens read from cache.
    pub cache_read: u64,
    /// Number of tokens written to cache.
    pub cache_write: u64,
}

impl TokenUsage {
    /// Returns the sum of all token counts.
    pub fn total(&self) -> u64 {
        self.input + self.output + self.cache_read + self.cache_write
    }
}

/// Context provided to a model for generating responses.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Context {
    /// Files that provide context for model generation.
    pub files: Vec<FileContext>,
    /// System-level instructions for the model.
    pub system_prompt: String,
}

impl Context {
    /// Creates a new context with the given system prompt.
    pub fn new<T: Into<String>>(system_prompt: T) -> Self {
        Self {
            files: Vec::default(),
            system_prompt: system_prompt.into(),
        }
    }

    /// Adds file contexts to this context.
    #[must_use]
    pub fn with_files(mut self, files: Vec<FileContext>) -> Self {
        self.files = files;
        self
    }

    /// Formats all file contexts as a single string for inclusion in prompts.
    pub fn files_to_string(&self) -> String {
        self.files
            .iter()
            .map(|file| format!("// File: {}\n{}\n", file.path.display(), file.content))
            .collect::<Vec<_>>()
            .join("\n")
    }

    /// Estimates the total token count for this context using a simple heuristic.
    pub fn token_estimate(&self) -> usize {
        let files_len: usize = self.files.iter().map(|file| file.content.len()).sum();
        (self.system_prompt.len() + files_len) / 4
    }
}

/// A file and its content provided as context to a model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileContext {
    /// Path to the file.
    pub path: PathBuf,
    /// Text content of the file.
    pub content: String,
}

impl FileContext {
    /// # Errors
    /// Returns an error if the file cannot be read
    pub fn from_path(path: &PathBuf) -> Result<Self> {
        let content =
            read_to_string(path).map_err(|_| Error::FileNotFound(path.display().to_string()))?;

        Ok(Self {
            path: path.clone(),
            content,
        })
    }

    /// Creates a new file context with the given path and content.
    pub fn new(path: PathBuf, content: String) -> Self {
        Self { path, content }
    }
}
