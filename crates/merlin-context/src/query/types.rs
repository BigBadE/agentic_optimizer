//! Types for query analysis and context planning.

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Analyzed intent from a user query
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QueryIntent {
    /// The action the user wants to perform
    pub action: Action,
    /// Keywords extracted from the query
    pub keywords: Vec<String>,
    /// Entities mentioned (types, functions, modules)
    pub entities: Vec<String>,
    /// Scope of the change
    pub scope: Scope,
    /// Estimated complexity
    pub complexity: Complexity,
}

/// The type of action requested
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Action {
    /// Create new code/feature
    Create,
    /// Modify existing code
    Modify,
    /// Debug/fix an issue
    Debug,
    /// Explain or analyze code
    Explain,
    /// Refactor code
    Refactor,
    /// Search for something
    Search,
}

/// Scope of the change
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Scope {
    /// Single file or function
    Focused,
    /// Multiple related files in a module
    Module,
    /// Codebase-wide changes
    Codebase,
}

/// Query complexity level
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum Complexity {
    /// Simple queries (lookups, simple questions)
    Simple,
    /// Medium complexity (single-file edits)
    Medium,
    /// Complex queries (multi-file changes, architecture)
    Complex,
}

/// Plan for context expansion generated by the subagent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextPlan {
    /// Keywords extracted from query
    pub keywords: Vec<String>,
    /// Specific code symbols to search for (function/struct/trait names)
    pub symbols: Vec<String>,
    /// File patterns to include (e.g., "auth", "user", "session")
    pub file_patterns: Vec<String>,
    /// Whether to include tests
    pub include_tests: bool,
    /// Maximum context depth (how far to traverse)
    pub max_depth: usize,
    /// Expansion strategy to use
    pub strategy: ExpansionStrategy,
    /// Reasoning from the subagent
    pub reasoning: String,
}

impl Default for ContextPlan {
    fn default() -> Self {
        Self {
            keywords: Vec::default(),
            symbols: Vec::default(),
            file_patterns: Vec::default(),
            include_tests: false,
            max_depth: 2,
            strategy: ExpansionStrategy::Focused {
                symbols: Vec::default(),
            },
            reasoning: String::default(),
        }
    }
}

/// Strategy for expanding context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExpansionStrategy {
    /// Find specific symbols and their direct dependencies
    Focused {
        /// Symbols to focus on
        symbols: Vec<String>,
    },
    /// Broad search across files matching patterns
    Broad {
        /// File patterns to match
        patterns: Vec<String>,
    },
    /// Start from entry points and expand
    EntryPointBased {
        /// Entry point files
        entry_files: Vec<PathBuf>,
    },
    /// Search semantically for related concepts
    Semantic {
        /// Semantic search query
        query: String,
        /// Number of top results to return
        top_k: usize,
    },
}

impl ContextPlan {
    /// Create a new context plan
    pub fn new(strategy: ExpansionStrategy) -> Self {
        Self {
            strategy,
            ..Default::default()
        }
    }

    /// Add keywords to the plan
    #[must_use]
    pub fn with_keywords(mut self, keywords: Vec<String>) -> Self {
        self.keywords = keywords;
        self
    }

    /// Add symbols to find
    #[must_use]
    pub fn with_symbols(mut self, symbols: Vec<String>) -> Self {
        self.symbols = symbols;
        self
    }

    /// Add file patterns
    #[must_use]
    pub fn with_patterns(mut self, patterns: Vec<String>) -> Self {
        self.file_patterns = patterns;
        self
    }

    /// Set whether to include tests
    #[must_use]
    pub fn with_tests(mut self, include: bool) -> Self {
        self.include_tests = include;
        self
    }

    /// Set maximum depth
    #[must_use]
    pub fn with_max_depth(mut self, depth: usize) -> Self {
        self.max_depth = depth;
        self
    }

    /// Add reasoning
    #[must_use]
    pub fn with_reasoning(mut self, reasoning: String) -> Self {
        self.reasoning = reasoning;
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_query_intent_creation() {
        let intent = QueryIntent {
            action: Action::Create,
            keywords: vec!["test".to_owned()],
            entities: vec!["User".to_owned()],
            scope: Scope::Focused,
            complexity: Complexity::Simple,
        };

        assert_eq!(intent.action, Action::Create);
        assert_eq!(intent.keywords.len(), 1);
        assert_eq!(intent.entities.len(), 1);
        assert_eq!(intent.scope, Scope::Focused);
        assert_eq!(intent.complexity, Complexity::Simple);
    }

    #[test]
    fn test_action_variants() {
        use Action::*;

        assert_eq!(Create, Create);
        assert_ne!(Create, Modify);

        // Test all variants exist
        let actions = [Create, Modify, Debug, Explain, Refactor, Search];
        assert_eq!(actions.len(), 6);
    }

    #[test]
    fn test_scope_variants() {
        use Scope::*;

        assert_eq!(Focused, Focused);
        assert_ne!(Focused, Module);

        let scopes = [Focused, Module, Codebase];
        assert_eq!(scopes.len(), 3);
    }

    #[test]
    fn test_complexity_ordering() {
        assert!(Complexity::Simple < Complexity::Medium);
        assert!(Complexity::Medium < Complexity::Complex);
        assert!(Complexity::Simple < Complexity::Complex);

        assert_eq!(Complexity::Simple, Complexity::Simple);
        assert_ne!(Complexity::Simple, Complexity::Complex);
    }

    #[test]
    fn test_context_plan_default() {
        let plan = ContextPlan::default();

        assert!(plan.keywords.is_empty());
        assert!(plan.symbols.is_empty());
        assert!(plan.file_patterns.is_empty());
        assert!(!plan.include_tests);
        assert_eq!(plan.max_depth, 2);
        assert!(matches!(plan.strategy, ExpansionStrategy::Focused { .. }));
        assert!(plan.reasoning.is_empty());
    }

    #[test]
    fn test_context_plan_new() {
        let strategy = ExpansionStrategy::Semantic {
            query: "test".to_owned(),
            top_k: 10,
        };
        let plan = ContextPlan::new(strategy);

        assert!(matches!(plan.strategy, ExpansionStrategy::Semantic { .. }));
    }

    #[test]
    fn test_context_plan_builder() {
        let plan = ContextPlan::default()
            .with_keywords(vec!["auth".to_owned(), "login".to_owned()])
            .with_symbols(vec!["User".to_owned()])
            .with_patterns(vec!["*.rs".to_owned()])
            .with_tests(true)
            .with_max_depth(3)
            .with_reasoning("Need to understand auth flow".to_owned());

        assert_eq!(plan.keywords.len(), 2);
        assert_eq!(plan.symbols.len(), 1);
        assert_eq!(plan.file_patterns.len(), 1);
        assert!(plan.include_tests);
        assert_eq!(plan.max_depth, 3);
        assert!(!plan.reasoning.is_empty());
    }

    #[test]
    fn test_expansion_strategy_focused() {
        let strategy = ExpansionStrategy::Focused {
            symbols: vec!["main".to_owned()],
        };

        match strategy {
            ExpansionStrategy::Focused { symbols } => {
                assert_eq!(symbols.len(), 1);
            }
            _ => panic!("Expected Focused strategy"),
        }
    }

    #[test]
    fn test_expansion_strategy_broad() {
        let strategy = ExpansionStrategy::Broad {
            patterns: vec!["test_*.rs".to_owned()],
        };

        match strategy {
            ExpansionStrategy::Broad { patterns } => {
                assert_eq!(patterns.len(), 1);
            }
            _ => panic!("Expected Broad strategy"),
        }
    }

    #[test]
    fn test_expansion_strategy_entry_point() {
        let strategy = ExpansionStrategy::EntryPointBased {
            entry_files: vec![PathBuf::from("src/main.rs")],
        };

        match strategy {
            ExpansionStrategy::EntryPointBased { entry_files } => {
                assert_eq!(entry_files.len(), 1);
            }
            _ => panic!("Expected EntryPointBased strategy"),
        }
    }

    #[test]
    fn test_expansion_strategy_semantic() {
        let strategy = ExpansionStrategy::Semantic {
            query: "authentication logic".to_owned(),
            top_k: 5,
        };

        match strategy {
            ExpansionStrategy::Semantic { query, top_k } => {
                assert_eq!(query, "authentication logic");
                assert_eq!(top_k, 5);
            }
            _ => panic!("Expected Semantic strategy"),
        }
    }

    #[test]
    fn test_serde_query_intent() {
        use serde_json::{from_str, to_string};

        let intent = QueryIntent {
            action: Action::Modify,
            keywords: vec!["func".to_owned()],
            entities: vec![],
            scope: Scope::Module,
            complexity: Complexity::Medium,
        };

        let json = to_string(&intent).expect("serialize");
        let deserialized: QueryIntent = from_str(&json).expect("deserialize");

        assert_eq!(deserialized.action, Action::Modify);
        assert_eq!(deserialized.scope, Scope::Module);
        assert_eq!(deserialized.complexity, Complexity::Medium);
    }

    #[test]
    fn test_serde_context_plan() {
        use serde_json::{from_str, to_string};

        let plan = ContextPlan::default().with_keywords(vec!["test".to_owned()]);

        let json = to_string(&plan).expect("serialize");
        let deserialized: ContextPlan = from_str(&json).expect("deserialize");

        assert_eq!(deserialized.keywords.len(), 1);
        assert_eq!(deserialized.max_depth, 2);
    }
}
