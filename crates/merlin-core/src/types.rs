use serde::{Deserialize, Serialize};
use std::fs::read_to_string;
use std::path::PathBuf;

use crate::{CoreResult, Error};

/// A query submitted to a model provider for processing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Query {
    /// The text content of the query.
    pub text: String,
    /// Optional conversation identifier for maintaining context across queries.
    pub conversation_id: Option<String>,
    /// Paths to files that provide additional context for the query.
    pub files_context: Vec<PathBuf>,
}

impl Query {
    /// Creates a new query with the given text.
    pub fn new<T: Into<String>>(text: T) -> Self {
        Self {
            text: text.into(),
            conversation_id: None,
            files_context: Vec::default(),
        }
    }

    /// Adds file paths to provide context for this query.
    #[must_use]
    pub fn with_files(mut self, files: Vec<PathBuf>) -> Self {
        self.files_context = files;
        self
    }
}

/// A response generated by a model provider.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    /// The generated text content.
    pub text: String,
    /// Confidence score for the response (0.0 to 1.0).
    pub confidence: f64,
    /// Token usage statistics for this generation.
    pub tokens_used: TokenUsage,
    /// Name of the provider that generated this response.
    pub provider: String,
    /// Time taken to generate the response in milliseconds.
    pub latency_ms: u64,
}

/// Token usage statistics for a model invocation.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TokenUsage {
    /// Number of input tokens processed.
    pub input: u64,
    /// Number of output tokens generated.
    pub output: u64,
    /// Number of tokens read from cache.
    pub cache_read: u64,
    /// Number of tokens written to cache.
    pub cache_write: u64,
}

impl TokenUsage {
    /// Returns the sum of all token counts.
    pub fn total(&self) -> u64 {
        self.input + self.output + self.cache_read + self.cache_write
    }
}

/// Context provided to a model for generating responses.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Context {
    /// Files that provide context for model generation.
    pub files: Vec<FileContext>,
    /// System-level instructions for the model.
    pub system_prompt: String,
}

impl Context {
    /// Creates a new context with the given system prompt.
    pub fn new<T: Into<String>>(system_prompt: T) -> Self {
        Self {
            files: Vec::default(),
            system_prompt: system_prompt.into(),
        }
    }

    /// Adds file contexts to this context.
    #[must_use]
    pub fn with_files(mut self, files: Vec<FileContext>) -> Self {
        self.files = files;
        self
    }

    /// Adds additional content to the system prompt.
    #[must_use]
    pub fn with_additional_content(mut self, content: &str) -> Self {
        self.system_prompt.push_str("\n\n");
        self.system_prompt.push_str(content);
        self
    }

    /// Formats all file contexts as a single string for inclusion in prompts.
    pub fn files_to_string(&self) -> String {
        self.files
            .iter()
            .map(|file| format!("// File: {}\n{}\n", file.path.display(), file.content))
            .collect::<Vec<_>>()
            .join("\n")
    }

    /// Estimates the total token count for this context using a simple heuristic.
    pub fn token_estimate(&self) -> usize {
        let files_len: usize = self.files.iter().map(|file| file.content.len()).sum();
        (self.system_prompt.len() + files_len) / 4
    }
}

/// A file and its content provided as context to a model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileContext {
    /// Path to the file.
    pub path: PathBuf,
    /// Text content of the file.
    pub content: String,
}

impl FileContext {
    /// # Errors
    /// Returns an error if the file cannot be read
    pub fn from_path(path: &PathBuf) -> CoreResult<Self> {
        let content =
            read_to_string(path).map_err(|_| Error::FileNotFound(path.display().to_string()))?;

        Ok(Self {
            path: path.clone(),
            content,
        })
    }

    /// Creates a new file context with the given path and content.
    pub fn new(path: PathBuf, content: String) -> Self {
        Self { path, content }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use merlin_deps::serde_json::{from_str, to_string};
    use merlin_deps::tempfile::TempDir;
    use std::fs::write;

    // REMOVED: test_query_new - Constructor test

    #[test]
    fn test_query_with_files() {
        let files = vec![PathBuf::from("file1.rs"), PathBuf::from("file2.rs")];
        let query = Query::new("test").with_files(files.clone());
        assert_eq!(query.files_context, files);
    }

    #[test]
    fn test_query_serialization() {
        let query = Query::new("test query").with_files(vec![PathBuf::from("test.rs")]);
        let json = to_string(&query).unwrap();
        let deserialized: Query = from_str(&json).unwrap();
        assert_eq!(query.text, deserialized.text);
        assert_eq!(query.files_context, deserialized.files_context);
    }

    #[test]
    fn test_token_usage_total() {
        let usage = TokenUsage {
            input: 100,
            output: 50,
            cache_read: 20,
            cache_write: 10,
        };
        assert_eq!(usage.total(), 180);
    }

    // REMOVED: test_token_usage_default - Constructor test

    // REMOVED: test_context_new - Constructor test

    #[test]
    fn test_context_with_files() {
        let files = vec![FileContext::new(
            PathBuf::from("test.rs"),
            "content".to_owned(),
        )];
        let context = Context::new("prompt").with_files(files);
        assert_eq!(context.files.len(), 1);
        assert_eq!(context.files[0].path, PathBuf::from("test.rs"));
    }

    #[test]
    fn test_context_files_to_string() {
        let files = vec![
            FileContext::new(PathBuf::from("file1.rs"), "content1".to_owned()),
            FileContext::new(PathBuf::from("file2.rs"), "content2".to_owned()),
        ];
        let context = Context::new("prompt").with_files(files);
        let result = context.files_to_string();
        assert!(result.contains("// File: file1.rs"));
        assert!(result.contains("content1"));
        assert!(result.contains("// File: file2.rs"));
        assert!(result.contains("content2"));
    }

    #[test]
    fn test_context_token_estimate() {
        let files = vec![FileContext::new(PathBuf::from("test.rs"), "a".repeat(100))];
        let context = Context::new("prompt").with_files(files);
        // (6 + 100) / 4 = 26
        assert_eq!(context.token_estimate(), 26);
    }

    // REMOVED: test_file_context_new - Constructor test

    #[test]
    fn test_file_context_from_path() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        write(&file_path, "test content").unwrap();

        let file_context = FileContext::from_path(&file_path).unwrap();
        assert_eq!(file_context.path, file_path);
        assert_eq!(file_context.content, "test content");
    }

    #[test]
    fn test_file_context_from_path_not_found() {
        let path = PathBuf::from("nonexistent.txt");
        let result = FileContext::from_path(&path);
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), Error::FileNotFound(_)));
    }

    #[test]
    fn test_response_serialization() {
        let response = Response {
            text: "response text".to_owned(),
            confidence: 0.95,
            tokens_used: TokenUsage {
                input: 100,
                output: 50,
                cache_read: 0,
                cache_write: 0,
            },
            provider: "test-provider".to_owned(),
            latency_ms: 250,
        };

        let json = to_string(&response).unwrap();
        let deserialized: Response = from_str(&json).unwrap();
        assert_eq!(response.text, deserialized.text);
        assert!((response.confidence - deserialized.confidence).abs() < f64::EPSILON);
        assert_eq!(response.provider, deserialized.provider);
    }
}
