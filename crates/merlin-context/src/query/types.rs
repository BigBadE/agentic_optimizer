//! Types for query analysis and context planning.

use std::path::PathBuf;
use serde::{Deserialize, Serialize};

/// Analyzed intent from a user query
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QueryIntent {
    /// The action the user wants to perform
    pub action: Action,
    /// Keywords extracted from the query
    pub keywords: Vec<String>,
    /// Entities mentioned (types, functions, modules)
    pub entities: Vec<String>,
    /// Scope of the change
    pub scope: Scope,
    /// Estimated complexity
    pub complexity: Complexity,
}

/// The type of action requested
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Action {
    /// Create new code/feature
    Create,
    /// Modify existing code
    Modify,
    /// Debug/fix an issue
    Debug,
    /// Explain or analyze code
    Explain,
    /// Refactor code
    Refactor,
    /// Search for something
    Search,
}

/// Scope of the change
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Scope {
    /// Single file or function
    Focused,
    /// Multiple related files in a module
    Module,
    /// Codebase-wide changes
    Codebase,
}

/// Query complexity level
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum Complexity {
    /// Simple queries (lookups, simple questions)
    Simple,
    /// Medium complexity (single-file edits)
    Medium,
    /// Complex queries (multi-file changes, architecture)
    Complex,
}

/// Plan for context expansion generated by the subagent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextPlan {
    /// Keywords extracted from query
    pub keywords: Vec<String>,
    /// Specific code symbols to search for (function/struct/trait names)
    pub symbols: Vec<String>,
    /// File patterns to include (e.g., "auth", "user", "session")
    pub file_patterns: Vec<String>,
    /// Whether to include tests
    pub include_tests: bool,
    /// Maximum context depth (how far to traverse)
    pub max_depth: usize,
    /// Expansion strategy to use
    pub strategy: ExpansionStrategy,
    /// Reasoning from the subagent
    pub reasoning: String,
}

impl Default for ContextPlan {
    fn default() -> Self {
        Self {
            keywords: Vec::new(),
            symbols: Vec::new(),
            file_patterns: Vec::new(),
            include_tests: false,
            max_depth: 2,
            strategy: ExpansionStrategy::Focused { symbols: Vec::new() },
            reasoning: String::new(),
        }
    }
}

/// Strategy for expanding context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExpansionStrategy {
    /// Find specific symbols and their direct dependencies
    Focused {
        /// Symbols to focus on
        symbols: Vec<String>,
    },
    /// Broad search across files matching patterns
    Broad {
        /// File patterns to match
        patterns: Vec<String>,
    },
    /// Start from entry points and expand
    EntryPointBased {
        /// Entry point files
        entry_files: Vec<PathBuf>,
    },
    /// Search semantically for related concepts
    Semantic {
        /// Semantic search query
        query: String,
        /// Number of top results to return
        top_k: usize,
    },
}

impl ContextPlan {
    /// Create a new context plan
    #[must_use]
    pub fn new(strategy: ExpansionStrategy) -> Self {
        Self {
            strategy,
            ..Default::default()
        }
    }

    /// Add keywords to the plan
    #[must_use]
    pub fn with_keywords(mut self, keywords: Vec<String>) -> Self {
        self.keywords = keywords;
        self
    }

    /// Add symbols to find
    #[must_use]
    pub fn with_symbols(mut self, symbols: Vec<String>) -> Self {
        self.symbols = symbols;
        self
    }

    /// Add file patterns
    #[must_use]
    pub fn with_patterns(mut self, patterns: Vec<String>) -> Self {
        self.file_patterns = patterns;
        self
    }

    /// Set whether to include tests
    #[must_use]
    pub fn with_tests(mut self, include: bool) -> Self {
        self.include_tests = include;
        self
    }

    /// Set maximum depth
    #[must_use]
    pub fn with_max_depth(mut self, depth: usize) -> Self {
        self.max_depth = depth;
        self
    }

    /// Add reasoning
    #[must_use]
    pub fn with_reasoning(mut self, reasoning: String) -> Self {
        self.reasoning = reasoning;
        self
    }
}
