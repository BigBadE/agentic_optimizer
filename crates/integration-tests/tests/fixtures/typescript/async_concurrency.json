{
  "name": "TypeScript Async Concurrency and Promise Handling",
  "description": "Tests advanced TypeScript async/await patterns, promise chaining, error propagation, and concurrent operations",
  "tags": [
    "typescript",
    "async",
    "promises",
    "concurrency",
    "error-handling"
  ],
  "setup": {
    "files": {
      "task1.txt": "Task 1 data",
      "task2.txt": "Task 2 data",
      "task3.txt": "Task 3 data"
    },
    "terminal_size": [
      80,
      24
    ]
  },
  "events": [
    {
      "type": "user_input",
      "data": {
        "text": "Read files sequentially with promise chaining",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "promise chaining",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code(): Promise<string> {",
          "  const result1 = await readFile('task1.txt');",
          "  const result2 = await readFile('task2.txt');",
          "  const result3 = await readFile('task3.txt');",
          "  ",
          "  const combined = `${result1} -> ${result2} -> ${result3}`;",
          "  await writeFile('sequential.txt', combined);",
          "  ",
          "  return `Sequential read complete: ${combined}`;",
          "}"
        ]
      },
      "verify": {
        "files": [
          {
            "path": "sequential.txt",
            "exists": true,
            "contains": [
              "Task 1 data",
              "Task 2 data",
              "Task 3 data"
            ]
          }
        ],
        "execution": {}
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Handle promise rejection gracefully",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "promise rejection",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code(): Promise<string> {",
          "  let successCount = 0;",
          "  let errorCount = 0;",
          "  ",
          "  try {",
          "    await readFile('task1.txt');",
          "    successCount++;",
          "  } catch (e) {",
          "    errorCount++;",
          "  }",
          "  ",
          "  try {",
          "    await readFile('nonexistent.txt');",
          "    successCount++;",
          "  } catch (e) {",
          "    errorCount++;",
          "  }",
          "  ",
          "  try {",
          "    await readFile('task2.txt');",
          "    successCount++;",
          "  } catch (e) {",
          "    errorCount++;",
          "  }",
          "  ",
          "  return `Success: ${successCount}, Errors: ${errorCount}`;",
          "}"
        ]
      },
      "verify": {
        "execution": {}
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Create complex async workflow with multiple stages",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "complex async workflow",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code(): Promise<string> {",
          "  // Stage 1: Read input",
          "  const input = await readFile('task1.txt');",
          "  ",
          "  // Stage 2: Process (uppercase)",
          "  const processed = input.toUpperCase();",
          "  await writeFile('stage1.txt', processed);",
          "  ",
          "  // Stage 3: Verify write",
          "  const verified = await readFile('stage1.txt');",
          "  ",
          "  // Stage 4: Transform again",
          "  const final = `[PROCESSED] ${verified}`;",
          "  await writeFile('final_output.txt', final);",
          "  ",
          "  return `Workflow complete: ${final}`;",
          "}"
        ]
      },
      "verify": {
        "files": [
          {
            "path": "stage1.txt",
            "exists": true,
            "contains": [
              "TASK 1 DATA"
            ]
          },
          {
            "path": "final_output.txt",
            "exists": true,
            "contains": [
              "[PROCESSED] TASK 1 DATA"
            ]
          }
        ],
        "execution": {}
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test async error propagation through call stack",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "error propagation",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code(): Promise<string> {",
          "  async function innerFunction() {",
          "    // This will throw",
          "    const content = await readFile('does_not_exist.txt');",
          "    return content;",
          "  }",
          "  ",
          "  async function middleFunction() {",
          "    // Error propagates through here",
          "    return await innerFunction();",
          "  }",
          "  ",
          "  try {",
          "    await middleFunction();",
          "    return 'Should not reach here';",
          "  } catch (error) {",
          "    return `Caught error at top level: ${error}`;",
          "  }",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "return_value_matches": "Caught error at top level"
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Combine bash and file operations asynchronously",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "bash and file operations asynchronously",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code(): Promise<string> {",
          "  // Read file",
          "  const data = await readFile('task1.txt');",
          "  ",
          "  // Process in TypeScript (avoid bash pipe issues)",
          "  const uppercase = data.toUpperCase();",
          "  ",
          "  // Write result",
          "  await writeFile('bash_processed.txt', uppercase);",
          "  ",
          "  // Verify file was written",
          "  const verify = await readFile('bash_processed.txt');",
          "  const size = verify.length;",
          "  ",
          "  return `Processed via bash, size: ${size} bytes`;",
          "}"
        ]
      },
      "verify": {
        "files": [
          {
            "path": "bash_processed.txt",
            "exists": true,
            "contains": [
              "TASK 1 DATA"
            ]
          }
        ],
        "execution": {}
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test async function returning complex objects",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "returning complex objects",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code() {",
          "  const files = [];",
          "  ",
          "  for (let i = 1; i <= 3; i++) {",
          "    const content = await readFile(`task${i}.txt`);",
          "    files.push({",
          "      name: `task${i}.txt`,",
          "      content: content.trim(),",
          "      length: content.length",
          "    });",
          "  }",
          "  ",
          "  return {",
          "    done: true,",
          "    result: `Processed ${files.length} files`,",
          "    files: files,",
          "    totalSize: files.reduce((sum, f) => sum + f.length, 0)",
          "  };",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "return_type": "object"
        }
      }
    }
  ],
  "final_verify": {
    "execution": {},
    "files": [
      {
        "path": "sequential.txt",
        "exists": true
      },
      {
        "path": "stage1.txt",
        "exists": true
      },
      {
        "path": "final_output.txt",
        "exists": true,
        "contains": [
          "[PROCESSED]"
        ]
      },
      {
        "path": "bash_processed.txt",
        "exists": true
      }
    ]
  }
}
