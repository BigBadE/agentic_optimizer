{
  "name": "TypeScript Error Handling",
  "description": "Tests edge cases and error handling including syntax errors, runtime errors, and tool failures",
  "tags": [
    "typescript",
    "errors",
    "edge-cases"
  ],
  "setup": {
    "files": {},
    "env_vars": {},
    "terminal_size": [
      80,
      24
    ],
    "tools": [
      "BashTool"
    ]
  },
  "events": [
    {
      "type": "user_input",
      "data": {
        "text": "Test response with no code block",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test response with no code block",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  // Code without agent_code() call would be valid",
          "  return 'Code executed successfully';",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_executed": true
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test invalid TypeScript syntax",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test invalid TypeScript syntax",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "const x = {",
          "return { done: true };"
        ]
      },
      "verify": {
        "execution": {
          "error_occurred": "error"
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test missing closing brace",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test missing closing brace",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  const obj = {",
          "    field: 'value'",
          "  ",
          "  return obj;",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "error_occurred": "error"
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test runtime error - undefined variable",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test runtime error - undefined variable",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  return undefinedVariable.property;",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "error_occurred": "error"
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test runtime error - null reference",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test runtime error - null reference",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  const obj = null;",
          "  return obj.toString();",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "error_occurred": "error"
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test bash command failure",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test bash command failure",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code() {",
          "  try {",
          "    const result = await bash('nonexistent-command-xyz123');",
          "    return result.stdout;",
          "  } catch (error) {",
          "    return `Command failed as expected: ${error}`;",
          "  }",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_executed": true,
          "tools_called": [
            "bash"
          ]
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test grep on non-existent directory",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test grep on non-existent directory",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code(): Promise<string> {",
          "  try {",
          "    let todos = await bash('grep -r TODO /nonexistent/directory/');",
          "    let failedFixtures = await bash('grep -r FAIL /nonexistent/directory/');",
          "    ",
          "    let todosList = todos.stdout.split('\\n').filter(line => line.includes('TODO')).map(line => line.trim());",
          "    let failedFixturesList = failedFixtures.stdout.split('\\n').filter(line => line.includes('FAIL')).map(line => line.trim());",
          "    ",
          "    let result = 'List of todos:\\n' + todosList.join('\\n') + '\\n\\nList of failed fixtures:\\n' + failedFixturesList.join('\\n');",
          "    ",
          "    return result;",
          "  } catch (error) {",
          "    return `Grep failed as expected on non-existent directory: ${error}`;",
          "  }",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_executed": true,
          "tools_called": [
            "bash"
          ]
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test type error - wrong type",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test type error - wrong type",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  const x: number = 'not a number';",
          "  return x;",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_parsed": true
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test division by zero",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test division by zero",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  const result = 10 / 0;",
          "  return result;",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_executed": true
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test JSON parse error",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test JSON parse error",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  const invalidJson = '{invalid json}';",
          "  return JSON.parse(invalidJson);",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "error_occurred": "error"
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test array index out of bounds",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test array index out of bounds",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  const arr = [1, 2, 3];",
          "  return arr[999];",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_executed": true
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test Promise rejection handling",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test Promise rejection handling",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "async function agent_code() {",
          "  return new Promise((resolve, reject) => {",
          "    reject(new Error('Promise rejected'));",
          "  });",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "error_occurred": "Promise rejected"
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test infinite loop detection",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test infinite loop detection",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  let count = 0;",
          "  while (true) {",
          "    count++;",
          "    if (count > 1000000) break;",
          "  }",
          "  return count;",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_executed": true
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test empty code block",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test empty code block",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code() {",
          "  // Empty function body",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "typescript_executed": true
        }
      }
    },
    {
      "type": "user_input",
      "data": {
        "text": "Test malformed function syntax",
        "submit": true
      }
    },
    {
      "type": "llm_response",
      "trigger": {
        "pattern": "Test malformed function syntax",
        "match_type": "contains"
      },
      "response": {
        "typescript": [
          "function agent_code(",
          "  return 'test';",
          "}"
        ]
      },
      "verify": {
        "execution": {
          "error_occurred": "error"
        }
      }
    }
  ],
  "final_verify": {
    "execution": {
      "validation_passed": true
    }
  }
}
